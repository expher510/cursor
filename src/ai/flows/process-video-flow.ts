
'use server';
/**
 * @fileOverview A flow for processing YouTube videos to extract transcripts and metadata using the Piped API.
 *
 * - processVideo - A function that takes a YouTube video ID and returns its title, transcript, and other metadata.
 * - ProcessVideoInput - The input type for the processVideo function.
 * - ProcessVideoOutput - The return type for the processVideo function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';
import 'dotenv/config';

// XML to JSON-like Object Parser
function parseTranscriptXml(xml: string) {
    const lines = [];
    // Adjusted regex to be more robust against variations in XML structure
    const textNodes = xml.match(/<text start="[^"]+" dur="[^"]+">[^<]*<\/text>/g) || [];
    
    for (const node of textNodes) {
        const textMatch = node.match(/>([^<]*)</);
        // Decode HTML entities
        const text = textMatch ? textMatch[1].replace(/&amp;#39;/g, "'").replace(/&quot;/g, '"').replace(/&amp;/g, '&') : '';

        const startMatch = node.match(/start="([^"]+)"/);
        const offset = startMatch ? parseFloat(startMatch[1]) * 1000 : 0;
        
        const durMatch = node.match(/dur="([^"]+)"/);
        const duration = durMatch ? parseFloat(durMatch[1]) * 1000 : 0;
        
        lines.push({ text, offset, duration });
    }
    return lines;
}


// Schema Definitions

const ProcessVideoInputSchema = z.object({
  videoId: z.string().describe('The ID of the YouTube video to process.'),
});
export type ProcessVideoInput = z.infer<typeof ProcessVideoInputSchema>;

const TranscriptItemSchema = z.object({
  text: z.string(),
  offset: z.number(),
  duration: z.number(),
  videoId: z.string().optional(),
});
export type TranscriptItem = z.infer<typeof TranscriptItemSchema>;

const VideoStatsSchema = z.object({
    views: z.number().optional(),
    likes: z.number().optional(),
    commentCount: z.number().optional(),
}).optional();
export type VideoStats = z.infer<typeof VideoStatsSchema>;


const ProcessVideoOutputSchema = z.object({
  title: z.string().describe('The title of the video.'),
  description: z.string().optional().nullable().describe('The description of the video.'),
  transcript: z.array(TranscriptItemSchema).describe('The transcript of the video with timestamps.'),
  stats: VideoStatsSchema.nullable(),
});
export type ProcessVideoOutput = z.infer<typeof ProcessVideoOutputSchema>;


// This is the public wrapper function that components will call.
export async function processVideo(input: ProcessVideoInput): Promise<ProcessVideoOutput> {
  return processVideoFlow(input);
}


// The Main Flow
const processVideoFlow = ai.defineFlow(
  {
    name: 'processVideoFlow',
    inputSchema: ProcessVideoInputSchema,
    outputSchema: ProcessVideoOutputSchema,
  },
  async ({ videoId }) => {
    
    // 1. Fetch metadata and subtitle info from Piped API
    const streamUrl = `https://pipedapi.kavin.rocks/streams/${videoId}`;
    let streamData;
    try {
        const streamResponse = await fetch(streamUrl);
        if (!streamResponse.ok) {
            throw new Error(`Piped API request for stream data failed with status ${streamResponse.status}`);
        }
        streamData = await streamResponse.json();
        
        // FOR DEBUGGING: Throw the raw response to show it in the UI
        throw new Error("API Response: \n" + JSON.stringify(streamData, null, 2));

    } catch(e: any) {
        console.error("Failed to fetch stream data from Piped API:", e.message);
        // Re-throw the error to be caught by the client
        throw e;
    }

    const { title, description, views, likes, subtitles } = streamData;
    
    // 2. Find an auto-generated subtitle URL
    const autoSub = subtitles?.find((sub: any) => sub.autoGenerated === true);
    if (!autoSub || !autoSub.url) {
        throw new Error("Could not retrieve transcript. The video may not have auto-generated subtitles enabled.");
    }
    
    // 3. Fetch the transcript content
    let transcriptXml;
    try {
        const transcriptResponse = await fetch(autoSub.url);
        if (!transcriptResponse.ok) {
            throw new Error(`Piped API request for transcript failed with status ${transcriptResponse.status}`);
        }
        transcriptXml = await transcriptResponse.text();
    } catch (e: any) {
        console.error("Failed to fetch transcript content:", e.message);
        throw new Error("Failed to download the transcript file.");
    }

    // 4. Parse the XML transcript
    const transcript = parseTranscriptXml(transcriptXml);
    if (!transcript || transcript.length === 0) {
        throw new Error("The retrieved transcript was empty or could not be parsed. It might be in an unsupported format.");
    }

    return {
      title: title || 'YouTube Video',
      description: description,
      transcript: transcript,
      stats: {
          views: views,
          likes: likes,
          commentCount: 0, 
      },
    };
  }
);
